(ns io.zane.plot
  (:require [clojure.core.matrix :as matrix]
            [clojure.math.numeric-tower :as math]
            [incanter.stats :as stats]))

(def braille
  [[\⠁ \⠈]
   [\⠂ \⠐]
   [\⠄ \⠠]
   [\⡀ \⢀]])

(def densities
  [\space \░ \▒ \▓ \█])

(def box-upper-left \┌)
(def box-upper-right \┐)
(def box-lower-left \└)
(def box-lower-right \┘)
(def box-horizontal \─)
(def box-vertical \│)

(def braille-cell-width (second (matrix/shape braille)))
(def braille-cell-height (first (matrix/shape braille)))

(defn union
  "Takes braille characters or \\space and combines them in such a way that the
  set of dots on the resulting character is the union of the dots on the input
  characters."
  ([a]
   a)
  ([a b]
   (cond (= \space a) b
         (= \space b) a
         :else (char (bit-or (int a)
                             (int b))))))

(defn fill
  "Returns a two-dimensional array of the provided dimensions populated by values
  generated by the zero-argument function f."
  [f width height]
  (let [row-f #(into [] (take width (repeatedly f)))]
    (into [] (take height (repeatedly row-f)))))

(defn braille-char
  "Takes a two-dimensional width 2 height 4 array of booleans and produces from it
  the corresponding braille character."
  [grid]
  (transduce (comp (map-indexed
                    (fn [y row]
                      (map-indexed
                       (fn [x cell]
                         (if cell
                           (get-in braille [y x])
                           \space))
                       row)))
                   cat)
             union
             \space
             grid))

(defn column-partition
  "Returns a lazy sequence of two-dimensional arrays from the provided two
  dimensional array. The arrays will be of width n. The height of the arrays
  will be the same as the height of the input array."
  [n m]
  (when (seq (first m))
    (lazy-seq (cons (map #(take n %)
                         m)
                    (column-partition n (map #(drop n %)
                                             m))))))

(defn divisible?
  "Returns true if x capable of being divided by y without a remainder."
  [x y]
  (zero? (rem x y)))

(defn compress-cells
  "Takes a two-dimensional matrix of booleans and compresses it into a smaller
  matrix using the function provided. f is expected to take a two-dimensional
  array with dimensions [height width]."
  [m height width f]
  (->> m
       (partition height)
       (map #(column-partition width %))
       (map #(map f %))))

(defn heatmap-char
  [maximum amount]
  (let [index (* (/ amount maximum)
                 (dec (count densities)))]
    (nth densities index)))

(defn compress-to-heatmap
  "Returns a two-dimensional matrix of characters where each character is shaded
  according to the values in the corresponding section of the source matrix."
  [m]
  (let [width 2
        height 4
        max-density (* width height)]
    (compress-cells m
                    height
                    width
                    (fn [a]
                      (let [amount (transduce (comp cat
                                                    (map #(if % 1 0)))
                                              +
                                              a)]
                        (heatmap-char max-density amount))))))

(defn compress-to-braille
  "Takes a two-dimensional matrix of booleans and compresses it into a smaller
  matrix of braille characters. The resulting matrix will be half as wide and
  one fourth as tall."
  [m]
  (compress-cells m
                  braille-cell-height
                  braille-cell-width
                  braille-char))

(defn matrix-str
  "Takes a matrix of characters and converts it into a string by adding newlines
  at the end of each row and then concatenating everything together."
  [m]
  (transduce (comp (map #(reduce str %))
                   (interpose \newline))
             str
             m))

(defn in-bounds?
  [{:keys [origin-x origin-y width height]
    :as window}
   x
   y]
  (let [max-x (+ origin-x width)
        max-y (+ origin-y height)]
    (and (< origin-x x max-x)
         (< origin-y y max-y))))

(defn cell-width
  [{window-width :width} canvas]
  (let [[_ canvas-width] (matrix/shape canvas)]
    (/ window-width canvas-width)))

(defn cell-height
  [{window-height :height} canvas]
  (let [[canvas-height _] (matrix/shape canvas)]
    (/ canvas-height canvas-height)))

(defn canvas-index
  [cell-count origin size n]
  (let [distance-from-origin (- n origin)]
    (math/round
     (* (/ distance-from-origin size)
        (dec cell-count)))))

(defn point
  "Returns the canvas with a point at the provided coordinates."
  [{:keys [origin-x origin-y width height] :as window} canvas x y]
  (if-not (in-bounds? window x y)
    canvas
    (let [[cell-height cell-width] (matrix/shape canvas)
          x-index (canvas-index cell-width origin-x width x)
          y-index (canvas-index cell-height origin-y height y)]
      (assoc-in canvas [y-index x-index] true))))

(defn points
  "Returns the canvas with points at the provided coordinates."
  ([canvas ps]
   (let [min-x (reduce min (map first ps))
         max-x (reduce max (map first ps))
         min-y (reduce min (map second ps))
         max-y (reduce max (map second ps))]
     (points {:origin-x min-x
              :origin-y min-y
              :width (- max-x min-x)
              :height (- max-y min-y)}
             canvas
             ps)))
  ([window canvas ps]
   (reduce (fn [canvas [x y]]
             (point window canvas x y))
           canvas
           ps)))

(defn box-around
  "Takes a two-dimensional array of characters and surrounds it with unicode
  characters that draw a box."
  [m]
  (let [[height width] (matrix/shape m)
        top [(vec (take width (repeat box-horizontal)))]
        bottom top
        box-center (repeat height box-vertical)
        left-wall (matrix/transpose
                   [(concat [box-upper-left]
                            box-center
                            [box-lower-left])])
        right-wall (matrix/transpose
                    [(concat [box-upper-right]
                             box-center
                             [box-lower-right])])]
    (matrix/join-along 1
                       left-wall
                       (matrix/join-along 0 top m bottom)
                       right-wall)))

(defn test-plot
  []
  (let [canvas (fill (constantly false) 80 40)
        xs (range -2 7 1/100)
        cos-points (for [x xs]
                     [x (float (Math/cos x))])
        sin-points (for [x xs]
                     [x (float (Math/sin x))])]
    (->> (points canvas (into cos-points sin-points))
         (compress-to-braille)
         (box-around)
         (matrix-str)
         (print))))

(defn test-scatter
  []
  (let [canvas (fill (constantly false) 80 40)
        size 500
        pts (map vector
                 (stats/sample-normal size)
                 (stats/sample-normal size))]
    (->> (points canvas pts)
         (compress-to-braille)
         (box-around)
         (matrix-str)
         (print))))

(defn test-heatmap
  []
  (let [canvas (fill (constantly false) 80 40)
        size 1000
        pts (map vector
                 (stats/sample-normal size)
                 (stats/sample-normal size))]
    (->> (points canvas pts)
         (compress-to-heatmap)
         (box-around)
         (matrix-str)
         (print))))

#_(test-plot)
#_(test-scatter)
#_(test-heatmap)
