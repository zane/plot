(ns io.zane.plot
  (:require [clojure.core.matrix :as matrix]
            [clojure.math.numeric-tower :as math]
            [incanter.stats :as stats]))

(def braille
  [[\⠁ \⠈]
   [\⠂ \⠐]
   [\⠄ \⠠]
   [\⡀ \⢀]])

(def densities
  [\space \░ \▒ \▓ \█])

(def box-upper-left \┌)
(def box-upper-right \┐)
(def box-lower-left \└)
(def box-lower-right \┘)
(def box-horizontal \─)
(def box-vertical \│)

(def braille-cell-width (second (matrix/shape braille)))
(def braille-cell-height (first (matrix/shape braille)))

(defn union
  "Takes braille characters or \\space and combines them in such a way that the
  set of dots on the resulting character is the union of the dots on the input
  characters."
  ([a]
   a)
  ([a b]
   (cond (= \space a) b
         (= \space b) a
         :else (char (bit-or (int a)
                             (int b))))))

(defn fill
  "Returns a two-dimensional array of the provided dimensions populated by values
  generated by the zero-argument function f."
  [f width height]
  (let [row-f #(into [] (take width (repeatedly f)))]
    (into [] (take height (repeatedly row-f)))))

(defn braille-char
  "Takes a two-dimensional width 2 height 4 array of booleans and produces from it
  the corresponding braille character."
  [grid]
  (transduce (comp (map-indexed
                    (fn [y row]
                      (map-indexed
                       (fn [x cell]
                         (if cell
                           (get-in braille [y x])
                           \space))
                       row)))
                   cat)
             union
             \space
             grid))

(defn column-partition
  "Returns a lazy sequence of two-dimensional arrays from the provided two
  dimensional array. The arrays will be of width n. The height of the arrays
  will be the same as the height of the input array."
  [n m]
  (when (seq (first m))
    (lazy-seq (cons (map #(take n %)
                         m)
                    (column-partition n (map #(drop n %)
                                             m))))))

(defn divisible?
  "Returns true if x capable of being divided by y without a remainder."
  [x y]
  (zero? (rem x y)))

(defn compress-cells
  "Takes a two-dimensional matrix of booleans and compresses it into a smaller
  matrix using the function provided. f is expected to take a two-dimensional
  array with dimensions [height width]."
  [m height width f]
  (->> m
       (partition height)
       (map #(column-partition width %))
       (map #(map f %))))

(defn heatmap-char
  [maximum amount]
  (let [index (* (/ amount maximum)
                 (dec (count densities)))]
    (nth densities index)))

(defn compress-to-heatmap
  "Returns a two-dimensional matrix of characters where each character is shaded
  according to the values in the corresponding section of the source matrix."
  [m]
  (let [width 2
        height 4
        max-density (* width height)]
    (compress-cells m
                    height
                    width
                    (fn [a]
                      (let [amount (transduce (comp cat
                                                    (map #(if % 1 0)))
                                              +
                                              a)]
                        (heatmap-char max-density amount))))))

(defn compress-to-braille
  "Takes a two-dimensional matrix of booleans and compresses it into a smaller
  matrix of braille characters. The resulting matrix will be half as wide and
  one fourth as tall."
  [m]
  (compress-cells m
                  braille-cell-height
                  braille-cell-width
                  braille-char))

(defn matrix-str
  "Takes a matrix of characters and converts it into a string by adding newlines
  at the end of each row and then concatenating everything together."
  [m]
  (transduce (comp (map #(reduce str %))
                   (interpose \newline))
             str
             m))

(defn in-bounds?
  "Returns whether a point is in a multidimensional matrix."
  [m ks]
  (loop [m m
         ks ks]
    (if-not (seq ks)
      true
      (let [index (first ks)]
        (and (<= 0 index (dec (count m)))
             (recur (nth m index)
                    (rest ks)))))))

(defn cell-width
  [{window-width :width} canvas]
  (let [[_ canvas-width] (matrix/shape canvas)]
    (/ window-width canvas-width)))

(defn cell-height
  [{window-height :height} canvas]
  (let [[canvas-height _] (matrix/shape canvas)]
    (/ canvas-height canvas-height)))

(defn canvas-index
  [cell-count origin size n]
  (let [distance-from-origin (- n origin)]
    (math/round
     (* (/ distance-from-origin size)
        (dec cell-count)))))

(defn point
  "Returns the canvas with a point at the provided coordinates."
  [{:keys [origin-x origin-y width height] :as window} canvas x y]
  (let [[cell-height cell-width] (matrix/shape canvas)
        x-index (canvas-index cell-width origin-x width x)
        y-index (- cell-height (canvas-index cell-height origin-y height y))]
    (if-not (in-bounds? canvas [y-index x-index])
      canvas
      (assoc-in canvas [y-index x-index] true))))

(defn points
  "Returns the canvas with points at the provided coordinates."
  ([canvas window ps]
   (reduce (fn [canvas [x y]]
             (point window canvas x y))
           canvas
           ps)))

(defn box-around
  "Takes a two-dimensional array of characters and surrounds it with unicode
  characters that draw a box."
  [m]
  (let [[height width] (matrix/shape m)
        top [(vec (take width (repeat box-horizontal)))]
        bottom top
        box-center (repeat height box-vertical)
        left-wall (matrix/transpose
                   [(concat [box-upper-left]
                            box-center
                            [box-lower-left])])
        right-wall (matrix/transpose
                    [(concat [box-upper-right]
                             box-center
                             [box-lower-right])])]
    (matrix/join-along 1
                       left-wall
                       (matrix/join-along 0 top m bottom)
                       right-wall)))

(defn text
  "Write a string onto a character matrix starting at the provided point and
  proceeding in the provided direction."
  [m s x y direction]
  (let [step (case direction :left dec, :right inc, :up inc, :down dec)
        dimension (case direction :left 1, :right 1, :up 0, :down 0)
        [height width] (matrix/shape m)]
    (loop [m m
           s (cond-> s (contains? #{:left :up} direction) reverse)
           point [y x]]
      (if-not (and (in-bounds? m point)
                   (seq s))
        m
        (recur (assoc-in m point (first s))
               (rest s)
               (update point dimension step))))))

(defn y-axis
  "Generates a y-axis from labels."
  [height y-min y-max]
  (let [formatter #(format "%.2f" (float %))
        y-min-str (formatter y-min)
        y-max-str (formatter y-max)
        width (reduce max (map count [y-min-str y-max-str]))]
    (-> (fill (constantly \space) width height)
        (text y-max-str (dec width) 1 :left)
        (text y-min-str (dec width) (dec (dec height)) :left))))

(defn attach-y-axis
  "Attaches y-axis labels to a matrix."
  [m y-min y-max]
  (let [height (count m)
        axis (y-axis height y-min y-max)]
    (matrix/join-along 1 axis m)))

(defn extremes
  "Returns a 2-tuple of the minimum and maximum values in the provided sequence."
  [xs]
  [(reduce min xs)
   (reduce max xs)])

(defn plot-points
  "Generates a plot from the provided data."
  ([pts compress]
   (plot-points pts compress {}))
  ([pts compress options]
   (let [defaults {:width 80 :height 40}
         {:keys [width height]} (merge defaults options)
         canvas (fill (constantly false) width height)
         [x-min x-max] (extremes (map first pts))
         [y-min y-max] (extremes (map second pts))]
     (-> canvas
         (points {:origin-x x-min
                  :origin-y y-min
                  :width (- x-max x-min)
                  :height (- y-max y-min)}
                 pts)
         compress
         box-around
         (attach-y-axis y-min y-max)
         (matrix-str)
         (print)))))

(defn test-sin-cos
  []
  (plot-points (mapcat (fn [x]
                         [[x (Math/cos x)]
                          [x (Math/sin x)]])
                       (range -2 7 1/100))
               compress-to-braille))

(defn test-pow
  []
  (plot-points (for [x (range 0 10 1/25)]
                 [x (float (* x x))])
               compress-to-braille))

(defn test-scatter
  []
  (let [size 500]
    (plot-points (map vector
                      (stats/sample-normal size)
                      (stats/sample-normal size))
                 compress-to-braille)))

(defn test-heatmap
  []
  (let [size 1000]
    (plot-points (map vector
                      (stats/sample-normal size)
                      (stats/sample-normal size))
                 compress-to-heatmap)))

#_(test-sin-cos)
#_(test-pow)
#_(test-scatter)
#_(test-heatmap)
